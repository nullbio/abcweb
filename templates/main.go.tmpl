package main

import (
	"fmt"
	"os"

	"{{.ImportPath}}/app"
	"{{.ImportPath}}/db"
	"{{.ImportPath}}/routes"
	"{{.ImportPath}}/rendering"
	"github.com/pkg/errors"
	"go.uber.org/zap"
	"github.com/volatiletech/abcweb/abcconfig"
	"github.com/volatiletech/abcweb/abcdatabase"
	"github.com/volatiletech/abcweb/abcrender"
	"github.com/spf13/pflag"
)

// These are set by the linker when running the "abcweb build" command.
var version = "unknown"
var buildTime = "unknown"

// Setup initializes the App object and calls all setup on its members
func Setup(a *app.App, flags *pflag.FlagSet) error {
	a.Render = rendering.New(a, "templates", a.AssetsManifest) 
	a.Router = routes.NewRouter(a, app.NewMiddlewares(a.Config, a.Session, a.Log))

	// Check if using the latest database migration if EnforceLatestMigration
	if a.Config.DB.EnforceMigration {
		migrated, version, err := abcdatabase.IsMigrated(a.Config.DB)
		if err != nil && err != abcdatabase.ErrNoMigrations {
			return errors.Wrap(err, "failed to check if using latest migration")
		}
		if !migrated && err != abcdatabase.ErrNoMigrations {
			return fmt.Errorf("database is out of sync with migrations, database version: %d", version)
		}
	}

	return nil
}

func main() {
	// Display the version hash and build time
	args := os.Args
	if len(args) == 2 && args[1] == "--version" {
		fmt.Println(fmt.Sprintf("Version: %q, built on %s.", version, buildTime))
		return
	}
	
	a := app.NewApp()

	// Setup the main app root command
	root := rootSetup(a)

	// Setup and bind the migrate command
	root.AddCommand(migrateSetup(a.Config))

	if err := root.Execute(); err != nil {
		a.Log.Fatal("root command execution failed", zap.Error(err))
	}
}

